<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CognitiveBiasGauge - Анализатор когнитивных искажений</title>
    <meta name="description" content="SPA для анализа мыслей на когнитивные искажения с использованием AI">
    
    <!-- Google Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    
    <!-- Font Awesome -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    
    <!-- Tailwind CSS через CDN -->
    <link href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css" rel="stylesheet">
    
    <style>
        .compact-card {
            border-radius: 10px;
            transition: all 0.2s ease;
        }
        .compact-card:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.08);
        }
        .thought-input {
            min-height: 100px;
            resize: vertical;
        }
        .compact-button {
            padding: 0.5rem 1rem;
            font-size: 0.875rem;
            border-radius: 6px;
        }
        .compact-badge {
            padding: 0.25rem 0.75rem;
            font-size: 0.75rem;
            border-radius: 12px;
        }
        .dense-list-item {
            padding: 0.75rem 1rem;
            border-bottom: 1px solid #e5e7eb;
        }
        .dense-list-item:last-child {
            border-bottom: none;
        }
        .compact-header {
            padding: 0.75rem 0;
            background: linear-gradient(135deg, #4f46e5 0%, #7c3aed 100%);
        }
        .compact-footer {
            padding: 1.5rem 0;
            font-size: 0.875rem;
        }
        .progress-bar {
            height: 4px;
            border-radius: 2px;
        }
        .loading-dots:after {
            content: ' .';
            animation: dots 1.5s steps(5, end) infinite;
        }
        @keyframes dots {
            0%, 20% { content: ' .'; }
            40% { content: ' ..'; }
            60% { content: ' ...'; }
            80%, 100% { content: ''; }
        }
        [x-cloak] { display: none !important; }
    </style>
</head>
<body class="bg-gray-50 font-sans text-gray-800 text-sm min-h-screen">
    <!-- Alpine.js Component Container -->
    <div x-data="cognitiveBiasApp" x-init="init()" class="min-h-screen flex flex-col">
        <!-- Compact Header -->
        <header class="compact-header text-white shadow-sm">
            <div class="container mx-auto px-4">
                <div class="flex justify-between items-center">
                    <div>
                        <h1 class="text-xl font-bold">
                            <i class="fas fa-brain mr-2"></i>CognitiveBiasGauge
                        </h1>
                        <p class="text-primary-100 text-xs opacity-80 mt-0.5">AI анализатор когнитивных искажений</p>
                    </div>
                    <div class="flex space-x-2">
                        <button @click="activeTab = 'history'"
                                :class="activeTab === 'history' ? 'bg-white text-indigo-600' : 'bg-indigo-700 text-white'"
                                class="compact-button font-medium transition-colors">
                            <i class="fas fa-history mr-1.5"></i>История
                        </button>
                    </div>
                </div>
            </div>
        </header>

        <!-- Main Content -->
        <main class="flex-1 container mx-auto px-4 py-4">
            <!-- Analysis Section -->
            <div x-show="activeTab === 'analyze'" x-cloak class="space-y-4">
                <!-- Model Loading Status -->
                <div x-show="isLoadingModel" class="bg-blue-50 border border-blue-200 compact-card p-4 text-center">
                    <div class="flex items-center justify-center space-x-3">
                        <i class="fas fa-spinner fa-spin text-blue-600"></i>
                        <div class="text-left">
                            <p class="text-blue-800 font-medium" x-text="loadingProgress"></p>
                            <div class="w-48 bg-gray-200 rounded-full progress-bar mt-1">
                                <div class="bg-blue-600 h-full rounded-full" :style="`width: ${modelLoadProgress}%`"></div>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Thought Input -->
                <div x-show="!isLoadingModel" class="bg-white compact-card shadow-sm p-4">
                    <h2 class="font-semibold text-gray-800 mb-2">
                        <i class="fas fa-edit mr-2 text-indigo-500"></i>Введите вашу мысль
                    </h2>
                    <textarea 
                        x-model="userThought"
                        placeholder="Опишите мысль или ситуацию для анализа. Пример: 'Если я не сдам проект идеально, меня уволят'..."
                        class="w-full thought-input p-3 border border-gray-300 rounded-lg focus:border-indigo-500 focus:ring-1 focus:ring-indigo-500 transition text-sm"
                        :disabled="isAnalyzing"></textarea>
                    
                    <div class="flex justify-between items-center mt-3">
                        <div class="text-xs text-gray-500">
                            <span x-text="userThought.length"></span> символов
                        </div>
                        <div class="flex space-x-2">
                            <button @click="userThought = ''" 
                                    class="compact-button border border-gray-300 text-gray-700 hover:bg-gray-50 transition-colors">
                                <i class="fas fa-eraser mr-1.5"></i>Очистить
                            </button>
                            <button @click="analyzeThought()"
                                    :disabled="!userThought.trim() || isAnalyzing"
                                    :class="!userThought.trim() || isAnalyzing ? 'bg-gray-400 cursor-not-allowed' : 'bg-indigo-600 hover:bg-indigo-700'"
                                    class="compact-button text-white font-medium transition-colors">
                                <i class="fas fa-play mr-1.5"></i>
                                <span x-text="isAnalyzing ? 'Анализ...' : 'Анализировать'"></span>
                            </button>
                        </div>
                    </div>
                </div>

                <!-- Analysis Results -->
                <div x-show="results && results.length > 0 && !isAnalyzing" class="bg-white compact-card shadow-sm p-4">
                    <div class="flex justify-between items-center mb-4">
                        <h2 class="font-semibold text-gray-800">
                            <i class="fas fa-chart-bar mr-2 text-green-500"></i>Результаты анализа
                        </h2>
                        <div class="flex items-center space-x-3">
                            <div class="flex items-center space-x-2">
                                <span class="text-xs text-gray-600">Порог:</span>
                                <input type="range" x-model="confidenceThreshold" min="0.1" max="0.9" step="0.05"
                                       class="w-24" @change="filterResults()">
                                <span class="text-xs font-mono w-10" x-text="(confidenceThreshold * 100).toFixed(0) + '%'"></span>
                            </div>
                            <button @click="saveToHistory()" class="text-indigo-600 hover:text-indigo-800" title="Сохранить">
                                <i class="fas fa-save"></i>
                            </button>
                        </div>
                    </div>

                    <!-- Summary Statistics -->
                    <div class="grid grid-cols-3 gap-2 mb-4">
                        <div class="bg-indigo-50 p-2 rounded-lg text-center">
                            <div class="text-indigo-700 font-bold" x-text="results.length"></div>
                            <div class="text-indigo-600 text-xs">Искажений</div>
                        </div>
                        <div class="bg-green-50 p-2 rounded-lg text-center">
                            <div class="text-green-700 font-bold" 
                                 x-text="(results.reduce((max, r) => Math.max(max, r.score), 0) * 100).toFixed(1) + '%'"></div>
                            <div class="text-green-600 text-xs">Макс. уверенность</div>
                        </div>
                        <div class="bg-purple-50 p-2 rounded-lg text-center">
                            <div class="text-purple-700 font-bold" 
                                 x-text="new Date().toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'})"></div>
                            <div class="text-purple-600 text-xs">Время</div>
                        </div>
                    </div>

                    <!-- Distortions List -->
                    <div class="space-y-2">
                        <template x-for="(result, index) in results" :key="result.id">
                            <div class="border border-gray-200 rounded-lg overflow-hidden hover:border-gray-300 transition-colors">
                                <div class="flex justify-between items-start p-3 bg-gray-50">
                                    <div class="flex-1">
                                        <h3 class="font-medium text-gray-800" x-text="result.name"></h3>
                                        <p class="text-gray-600 text-xs mt-0.5" x-text="result.description"></p>
                                    </div>
                                    <div class="text-right ml-2">
                                        <div class="text-lg font-bold text-indigo-700" 
                                             x-text="(result.score * 100).toFixed(1) + '%'"></div>
                                        <div class="text-xs text-gray-500">уверенность</div>
                                    </div>
                                </div>
                                <div class="p-3 pt-2">
                                    <div class="w-full bg-gray-200 rounded-full progress-bar mb-2">
                                        <div class="bg-gradient-to-r from-indigo-500 to-purple-600 h-full rounded-full" 
                                             :style="`width: ${result.score * 100}%`"></div>
                                    </div>
                                    <div class="text-xs text-gray-700" x-text="getExplanation(result.score)"></div>
                                </div>
                            </div>
                        </template>
                    </div>
                </div>
            </div>

            <!-- History Section -->
            <div x-show="activeTab === 'history'" x-cloak class="bg-white compact-card shadow-sm p-4">
                <h2 class="font-semibold text-gray-800 mb-3">
                    <i class="fas fa-history mr-2 text-indigo-500"></i>История анализов
                </h2>
                
                <div x-show="!history || history.length === 0" class="text-center py-6">
                    <i class="fas fa-clock text-3xl text-gray-300 mb-2"></i>
                    <p class="text-gray-500 text-sm">История анализов пуста</p>
                </div>

                <div x-show="history && history.length > 0" class="space-y-2">
                    <template x-for="(item, index) in history.slice().reverse()" :key="item.id">
                        <div class="dense-list-item hover:bg-gray-50 transition-colors">
                            <div class="flex justify-between items-start">
                                <div class="flex-1">
                                    <p class="text-gray-800 text-sm mb-1" x-text="item.thought.substring(0, 120) + (item.thought.length > 120 ? '...' : '')"></p>
                                    <div class="flex items-center text-xs text-gray-500">
                                        <i class="far fa-clock mr-1"></i>
                                        <span x-text="new Date(item.timestamp).toLocaleDateString() + ' ' + new Date(item.timestamp).toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'})"></span>
                                        <span class="mx-1">•</span>
                                        <span x-text="item.results.length + ' искажений'"></span>
                                    </div>
                                </div>
                                <button @click="loadFromHistory(item)" class="text-indigo-600 hover:text-indigo-800 ml-2" title="Загрузить">
                                    <i class="fas fa-redo text-sm"></i>
                                </button>
                            </div>
                            <div class="flex flex-wrap gap-1.5 mt-2">
                                <template x-for="result in item.results.slice(0, 4)" :key="result.id">
                                    <span class="compact-badge bg-indigo-100 text-indigo-800"
                                          x-text="result.name + ' (' + (result.score * 100).toFixed(0) + '%)'"></span>
                                </template>
                                <span x-show="item.results.length > 4" class="compact-badge bg-gray-100 text-gray-600">
                                    +<span x-text="item.results.length - 4"></span>
                                </span>
                            </div>
                        </div>
                    </template>
                </div>
                
                <div x-show="history && history.length > 0" class="flex justify-between items-center mt-4 pt-3 border-t border-gray-200">
                    <button @click="clearHistory()" class="text-red-600 hover:text-red-800 text-sm">
                        <i class="fas fa-trash mr-1.5"></i>Очистить историю
                    </button>
                    <button @click="exportHistory()" class="compact-button bg-indigo-600 text-white hover:bg-indigo-700">
                        <i class="fas fa-download mr-1.5"></i>Экспорт
                    </button>
                </div>
            </div>
        </main>

        <!-- Compact Footer -->
        <footer class="compact-footer border-t border-gray-200 bg-white">
            <div class="container mx-auto px-4">
                <div class="flex flex-col md:flex-row justify-between items-center">
                    <div class="mb-3 md:mb-0">
                        <div class="flex items-center">
                            <i class="fas fa-brain text-lg text-indigo-600 mr-2"></i>
                            <span class="font-medium text-gray-800">CognitiveBiasGauge</span>
                        </div>
                        <p class="text-gray-600 text-xs mt-0.5">
                            <span x-text="modelStatus"></span>
                            <span x-show="backendInfo" class="ml-1.5" x-text="'• ' + backendInfo"></span>
                        </p>
                    </div>
                    
                    <!-- Performance Monitoring -->
                    <div class="text-xs text-gray-500">
                        <div class="flex space-x-4">
                            <div>
                                <i class="fas fa-microchip mr-1"></i>
                                <span x-text="'Анализов: ' + (performanceStats ? performanceStats.totalAnalyses : 0)"></span>
                            </div>
                            <div x-show="performanceStats && performanceStats.lastAnalysisTime > 0">
                                <i class="fas fa-stopwatch mr-1"></i>
                                <span x-text="'Время: ' + performanceStats.lastAnalysisTime.toFixed(0) + 'ms'"></span>
                            </div>
                        </div>
                        <div class="text-gray-400 mt-1 text-center md:text-right">
                            © 2024 • Все вычисления выполняются локально
                        </div>
                    </div>
                </div>
            </div>
        </footer>
    </div>

    <!-- Alpine.js -->
    <script defer src="https://cdn.jsdelivr.net/npm/alpinejs@3.x.x/dist/cdn.min.js"></script>
    
    <!-- Main Application Script -->
    <script>
        // Инициализируем глобальную переменную для Alpine.js
        window.cognitiveBiasApp = () => {
            return {
                // Состояния
                activeTab: 'analyze',
                userThought: '',
                isLoadingModel: true,
                isAnalyzing: false,
                modelLoadProgress: 0,
                loadingProgress: 'Инициализация...',
                confidenceThreshold: 0.3,
                model: null,
                biasLibrary: [],
                isEmbedded: false,
                isProcessing: false,
                results: [],
                history: [],
                modelStatus: 'Загрузка модели...',
                backendInfo: 'WebGL',
                
                // Performance monitoring
                performanceStats: {
                    lastAnalysisTime: 0,
                    totalAnalyses: 0
                },
                
                // Кеш эмбеддингов
                embeddingCache: new Map(),
                
                // Семафор для контроля доступа к модели
                modelLock: false,
                
                // Инициализация при создании компонента
                async init() {
                    console.log('Инициализация приложения...');
                    
                    // Создаем библиотеку искажений
                    this.biasLibrary = this.createBiasLibrary();
                    
                    // Загружаем историю из localStorage
                    this.loadHistoryFromStorage();
                    
                    // Загружаем модель
                    await this.loadModelWithProgress();
                },
                
                // Function to create bias library
                createBiasLibrary() {
                    return [
                        {
                            "id": 1,
                            "name": "Всё или ничего (дихотомическое мышление)",
                            "description": "Оценка ситуаций в крайностях, без промежуточных вариантов.",
                            "passage": "Дихотомическое мышление заставляет человека воспринимать мир в чёрно-белых тонах, игнорируя полутона и нюансы. Люди с таким искажением склонны использовать крайние категории («всё» или «ничего»), не признавая возможности частичного успеха или неудачи. Например, студент может считать себя полным неудачником, если не получит максимальный балл за экзамен."
                        },
                        {
                            "id": 2,
                            "name": "Катастрофизация",
                            "description": "Преувеличение негативных последствий событий, ожидание худшего.",
                            "passage": "При катастрофизации человек склонен предвидеть наихудшие исходы даже в незначительных проблемах. Например, опоздание на встречу может казаться предвестником полного краха жизни. Такие мысли создают избыточный стресс и тревогу, мешая рационально оценивать ситуацию."
                        },
                        {
                            "id": 3,
                            "name": "Обесценивание положительного",
                            "description": "Игнорирование или минимизация положительных аспектов ситуации.",
                            "passage": "Это искажение заставляет человека не замечать или преуменьшать значимость хороших моментов в жизни. Например, человек может считать свои достижения незначительными, фокусируясь только на ошибках и недостатках. Это снижает самооценку и мешает наслаждаться успехами."
                        },
                        {
                            "id": 4,
                            "name": "Эмоциональное обоснование",
                            "description": "Оценка реальности на основе эмоций, а не фактов.",
                            "passage": "Когда человек опирается на эмоции, а не на объективные данные, он может делать неверные выводы о ситуации. Например, в состоянии тревоги человек может воспринимать нейтральные события как угрожающие, даже если нет реальных оснований для беспокойства."
                        },
                        {
                            "id": 5,
                            "name": "Навешивание ярлыков",
                            "description": "Категоризация людей или ситуаций на основе единичных событий.",
                            "passage": "Такое искажение приводит к формированию стереотипных представлений о людях или ситуациях. Например, после одной неудачи в общении человек может решить, что он «неудачник в отношениях», игнорируя свои предыдущие успехи. Это ограничивает восприятие и мешает видеть полную картину."
                        },
                        {
                            "id": 6,
                            "name": "Преувеличение/преуменьшение",
                            "description": "Искажение реальности, чрезмерное усиление негативных аспектов или умаление положительных.",
                            "passage": "Человек с таким искажением может либо раздувать проблемы до гигантских размеров, либо недооценивать свои достижения. Например, незначительная ошибка может казаться катастрофой, а значительные успехи — мелочью, не заслуживающей внимания."
                        },
                        {
                            "id": 7,
                            "name": "Ментальный фильтр (негативный фильтр)",
                            "description": "Фокусировка на негативных деталях, игнорирование положительных аспектов.",
                            "passage": "Этот тип искажения заставляет человека «просеивать» события через фильтр негатива, замечая только отрицательные стороны. Например, получив похвалу с небольшой критикой, человек может сосредоточиться только на критике, игнорируя положительные отзывы."
                        },
                        {
                            "id": 8,
                            "name": "Чтение мыслей",
                            "description": "Предположение о мыслях других без достаточных оснований.",
                            "passage": "Люди, подверженные этому искажению, уверены, что знают, о чём думают другие, даже без явных доказательств. Например, человек может решить, что его коллега плохо о нём думает, основываясь только на своих предположениях, а не на фактах."
                        },
                        {
                            "id": 9,
                            "name": "Сверхобобщение",
                            "description": "Выводы на основе ограниченного числа примеров, распространение частных случаев на общую картину.",
                            "passage": "Сверхобобщение приводит к формированию широких выводов на основе единичных случаев. Например, после одного неудачного свидания человек может решить, что «все отношения обречены на провал», игнорируя возможность того, что проблема была специфична для конкретной ситуации."
                        },
                        {
                            "id": 10,
                            "name": "Персонализация",
                            "description": "Восприятие событий как направленных лично против себя, принятие слишком большой ответственности за события.",
                            "passage": "При персонализации человек склонен считать себя причиной всех негативных событий, даже если его влияние на ситуацию минимально. Например, если команда не достигает цели, член команды может решить, что это полностью его вина, игнорируя вклад других участников и внешние факторы."
                        },
                        {
                            "id": 11,
                            "name": "Утверждения «мне следует» и «я должен»",
                            "description": "Жёсткие требования к себе и окружающим, использование долженствований.",
                            "passage": "Такие мыслительные шаблоны создают избыточное давление, заставляя человека чувствовать вину или стыд за несоответствие собственным жёстким стандартам. Например, мысли типа «я должен всегда быть идеальным» могут привести к хроническому стрессу и снижению самооценки."
                        },
                        {
                            "id": 12,
                            "name": "Туннельное зрение",
                            "description": "Сосредоточение на одной детали в ущерб общему контексту, упущение важной информации.",
                            "passage": "Туннельное зрение заставляет человека фокусироваться на одной детали, игнорируя остальной контекст. Например, при оценке работы человек может зациклиться на одном недостатке, не замечая множества достоинств и достижений. Это искажает общую картину и мешает принимать взвешенные решения."
                        }
                    ]
                },
                
                // Model loading function
                async loadModel() {
                    // 1. Проверяем, не загружена ли уже модель
                    if (this.model) {
                        console.log('Model already loaded');
                        return this.model;
                    }

                    try {
                        // Используем динамический импорт для Transformers.js
                        const { pipeline } = await import('https://cdn.jsdelivr.net/npm/@huggingface/transformers@3.0.0');
                        
                        // Используем маленькую модель для быстрой загрузки
                        const extractor = await pipeline('feature-extraction', 'Xenova/multilingual-e5-small', {
                            device: 'webgpu', 
                            dtype: 'q8', // Использование 8-битного квантования уменьшит потребление памяти
                        });
                        
                        console.log('Model loaded successfully');
                        return extractor;
                    } catch (error) {
                        console.error('Error loading model:', error);
                        throw error;
                    }
                },
                
                // Generate embeddings for bias library (батчевая обработка)
                async generateBiasEmbeddings() {
                    if (this.isProcessing || this.isEmbedded) return;

                    try {
                        this.isProcessing = true; // Блокируем повторные входы немедленно
                        // Собираем все тексты в один массив для батчевой обработки
                        const texts = this.biasLibrary.map(bias => bias.passage);
                        
                        // Генерируем эмбеддинги для всех текстов сразу
                        const embeddings = await this.model(texts, {
                            pooling: 'mean',
                            normalize: true
                        });
                        
                        // Сохраняем эмбеддинги
                        for (let i = 0; i < this.biasLibrary.length; i++) {
                            this.biasLibrary[i].embedding = Array.from(embeddings[i].data);
                        }
                        
                        // Update progress
                        this.modelLoadProgress = 90;
                        this.loadingProgress = 'Обработка искажений завершена';
                    
                        this.isEmbedded = true;
                    } catch (error) {
                        console.error('Error generating bias embeddings:', error);
                        // В случае ошибки генерируем эмбеддинги по одному
                        //await this.generateBiasEmbeddingsSequentially();
                    } finally {
                        this.isProcessing = false; // Освобождаем флаг в любом случае
                    }
                },
                
                // Альтернативный метод: генерация эмбеддингов по одному
                async generateBiasEmbeddingsSequentially() {
                    for (let i = 0; i < this.biasLibrary.length; i++) {
                        const bias = this.biasLibrary[i];
                        try {
                            const embedding = await this.model(bias.passage, {
                                pooling: 'mean',
                                normalize: true
                            });
                            
                            // Сохраняем эмбеддинг как обычный массив
                            bias.embedding = Array.from(embedding.data);
                            
                            // Update progress
                            this.modelLoadProgress = 60 + Math.floor((i / this.biasLibrary.length) * 30);
                            this.loadingProgress = `Обработка искажений: ${i + 1}/${this.biasLibrary.length}`;
                            
                            // Небольшая задержка между запросами
                            await new Promise(resolve => setTimeout(resolve, 100));
                            
                        } catch (error) {
                            console.error(`Error generating embedding for ${bias.name}:`, error);
                            // Продолжаем с другими искажениями
                        }
                    }
                },

                // Model loading with progress
                async loadModelWithProgress() {
                    try {
                        this.loadingProgress = 'Загрузка модели MiniLM...';
                        this.modelLoadProgress = 10;
                        
                        this.model = await this.loadModel();
                        
                        this.modelLoadProgress = 50;
                        this.loadingProgress = 'Подготовка библиотеки искажений...';
                        
                        // Generate embeddings for bias library
                        await this.generateBiasEmbeddings();
                        
                        this.modelLoadProgress = 100;
                        this.loadingProgress = 'Готово!';
                        this.modelStatus = 'Модель загружена ✓';
                        this.isLoadingModel = false;
                        
                    } catch (error) {
                        console.error('Initialization error:', error);
                        this.modelStatus = 'Ошибка загрузки модели';
                        this.loadingProgress = 'Ошибка: ' + error.message;
                        
                        // Если модель не загрузилась, показываем сообщение
                        setTimeout(() => {
                            if (this.isLoadingModel) {
                                this.modelStatus = 'Не удалось загрузить модель';
                                this.loadingProgress = 'Пожалуйста, обновите страницу';
                            }
                        }, 5000);
                    }
                },
                
                // Main analysis function с блокировкой
                async analyzeThought() {
                    if (!this.userThought.trim() || !this.model || this.modelLock) return;
                    
                    const startTime = performance.now();
                    this.isAnalyzing = true;
                    this.modelLock = true; // Блокируем модель
                    this.results = [];
                    
                    try {
                        // Кешируем эмбеддинги
                        const cacheKey = this.userThought.toLowerCase().trim();
                        
                        let thoughtEmbedding;
                        if (this.embeddingCache.has(cacheKey)) {
                            thoughtEmbedding = this.embeddingCache.get(cacheKey);
                        } else {
                            // Генерируем эмбеддинг для мысли пользователя
                            const embedding = await this.model(`query: ${this.userThought}`, {
                                pooling: 'mean',
                                normalize: true
                            });
                            
                            thoughtEmbedding = Array.from(embedding.data);
                            this.embeddingCache.set(cacheKey, thoughtEmbedding);
                            
                            // Ограничиваем размер кеша
                            if (this.embeddingCache.size > 50) {
                                const firstKey = this.embeddingCache.keys().next().value;
                                this.embeddingCache.delete(firstKey);
                            }
                        }
                        
                        // Вычисляем сходство со всеми искажениями
                        const matches = [];
                        //const { cos_sim } = await import('https://cdn.jsdelivr.net/npm/@huggingface/transformers@3.0.0');

                        for (const bias of this.biasLibrary) {
                            if (!bias.embedding) continue;
                            
                            // Вычисляем косинусное сходство между массивами
                            const score = this.cosineSimilarity(thoughtEmbedding, bias.embedding);
                            //const score = cos_sim(thoughtEmbedding, bias.embedding);

                            if (score >= this.confidenceThreshold) {
                                matches.push({
                                    id: bias.id,
                                    name: bias.name,
                                    description: bias.description,
                                    score: score,
                                    rawScore: score
                                });
                            }
                        }
                        
                        // Сортировка по убыванию сходства
                        matches.sort((a, b) => b.score - a.score);
                        this.results = matches;
                        
                        this.performanceStats.lastAnalysisTime = performance.now() - startTime;
                        this.performanceStats.totalAnalyses++;
                        
                        console.log(`Анализ завершен за ${this.performanceStats.lastAnalysisTime.toFixed(2)}мс`);
                        
                    } catch (error) {
                        console.error('Ошибка анализа:', error);
                        this.showError('Ошибка анализа', 'Пожалуйста, попробуйте снова или введите другой текст.');
                    } finally {
                        this.isAnalyzing = false;
                        this.modelLock = false; // Разблокируем модель
                    }
                },
                
                // Косинусное сходство между двумя массивами (чистый JavaScript)
                cosineSimilarity(a, b) {
                    if (a.length !== b.length) {
                        console.error('Размеры векторов не совпадают');
                        return 0;
                    }
                    
                    let dotProduct = 0;
                    let normA = 0;
                    let normB = 0;
                    
                    for (let i = 0; i < a.length; i++) {
                        dotProduct += a[i] * b[i];
                        normA += a[i] * a[i];
                        normB += b[i] * b[i];
                    }
                    
                    if (normA === 0 || normB === 0) {
                        return 0;
                    }
                    
                    return dotProduct / (Math.sqrt(normA) * Math.sqrt(normB));
                },
                
                // Filter results by threshold
                filterResults() {
                    this.results = this.results.map(r => ({
                        ...r,
                        score: r.rawScore >= this.confidenceThreshold ? r.rawScore : 0
                    })).filter(r => r.score > 0)
                      .sort((a, b) => b.score - a.score);
                },
                
                // Generate explanation based on score
                getExplanation(score) {
                    if (score >= 0.7) {
                        return "Высокая вероятность. Рекомендуется критически переосмыслить мысль.";
                    } else if (score >= 0.5) {
                        return "Средняя вероятность. Обратите внимание на возможное влияние.";
                    } else {
                        return "Низкая вероятность, но возможны элементы искажения.";
                    }
                },
                
                // Save current analysis to history
                saveToHistory() {
                    if (this.results.length === 0) return;
                    
                    const historyItem = {
                        id: Date.now(),
                        timestamp: new Date().toISOString(),
                        thought: this.userThought,
                        results: this.results.map(r => ({
                            id: r.id,
                            name: r.name,
                            score: r.score
                        }))
                    };
                    
                    this.history.push(historyItem);
                    
                    // Save to localStorage
                    try {
                        const storedHistory = JSON.parse(localStorage.getItem('cbg_history') || '[]');
                        storedHistory.push(historyItem);
                        localStorage.setItem('cbg_history', JSON.stringify(storedHistory.slice(-50)));
                    } catch (error) {
                        console.error('Error saving to localStorage:', error);
                    }
                    
                    alert('Анализ сохранен в историю!');
                },
                
                // Load history from localStorage
                loadHistoryFromStorage() {
                    try {
                        const storedHistory = JSON.parse(localStorage.getItem('cbg_history') || '[]');
                        this.history = storedHistory;
                    } catch (error) {
                        console.error('Error loading history:', error);
                        this.history = [];
                    }
                },
                
                // Load analysis from history
                loadFromHistory(item) {
                    this.userThought = item.thought;
                    this.results = item.results.map(r => ({
                        ...r,
                        description: this.biasLibrary.find(b => b.id === r.id)?.description || '',
                        rawScore: r.score
                    }));
                    this.activeTab = 'analyze';
                    
                    // Scroll to results
                    setTimeout(() => {
                        const resultsElement = document.querySelector('[x-show*="results.length"]');
                        if (resultsElement) {
                            resultsElement.scrollIntoView({ 
                                behavior: 'smooth' 
                            });
                        }
                    }, 100);
                },
                
                // Clear history
                clearHistory() {
                    if (confirm('Очистить всю историю анализов?')) {
                        this.history = [];
                        localStorage.removeItem('cbg_history');
                    }
                },
                
                // Export history
                exportHistory() {
                    const dataStr = JSON.stringify(this.history, null, 2);
                    const dataUri = 'data:application/json;charset=utf-8,'+ encodeURIComponent(dataStr);
                    
                    const exportFileDefaultName = `cognitivebias-history-${new Date().toISOString().split('T')[0]}.json`;
                    
                    const linkElement = document.createElement('a');
                    linkElement.setAttribute('href', dataUri);
                    linkElement.setAttribute('download', exportFileDefaultName);
                    linkElement.click();
                },
                
                // Show error
                showError(title, message) {
                    alert(`${title}: ${message}`);
                },
                
                // Clean up memory
                cleanupMemory() {
                    // Очищаем кеш эмбеддингов
                    this.embeddingCache.clear();
                    alert('Кеш очищен!');
                }
            };
        };
    </script>
</body>
</html>